// Copyright 2022 Cantab Research Ltd.
// Licensed under the MIT license. See LICENSE.txt in the project root for details.
#pragma once
#include "pipeline_orchestrator_decl.h"

template <std::size_t N>
constexpr static_string<N>::static_string(array_type& arr) : buf{} {
    for (std::size_t idx=0; idx < N; ++idx) {
        buf[idx] = arr[idx];
    }
}

// Equality of static_string checked by iterating over each character in the member buf
// and checking that they are the same
template <std::size_t N>
constexpr bool static_string<N>::operator==(const static_string& rhs) const {
    for (std::size_t idx{0}; idx < N; ++idx) {
        if (buf[idx] != rhs.buf[idx]) {
            return false;
        }
    }
    return true;
}

template <typename key, typename value>
constexpr kv<key, value>::kv(key k, value v) : k{k}, v{v} {};

template <std::size_t N, typename kv>
template <std::size_t ...Idx>
constexpr std::array<kv, N> static_map<N, kv>::make_array_impl(array_type& arr, std::index_sequence<Idx...>) {
    return std::array<kv, N>{arr[Idx]...};
}

template <std::size_t N, typename kv>
constexpr static_map<N, kv>::static_map(array_type& arr) : buf{make_array_impl(arr, std::make_index_sequence<N>{})} {}

// get works by linearly search over the member buf, looking at each kv
// If the key matches, we return the value
// If we get to the end and the key does not match, we throw
template <std::size_t N, typename kv>
constexpr decltype(std::declval<kv>().v) static_map<N, kv>::get(decltype(std::declval<kv>().k) key) const {
    for (auto it = buf.begin(); it != buf.end(); ++it) {
        if (it->k == key) {
            return it->v;
        }
    }
    throw "Item not in static_map!";
}

template <typename ComponentName, typename InputNameTuple, typename out, typename... in>
template <typename ...InputName>
pipeline_module<ComponentName, InputNameTuple, out, in...>::pipeline_module(ComponentName component_name, function_type work_function, InputName... input_names) : 
    work_function{work_function} {};

template <typename T, std::size_t N>
constexpr void static_vector<T, N>::push_back(T t) {
    buf[size] = t;
    ++size;
  }

// The Pipeline internally owns and stores the Components, PipelineBuffers and Threads on which the Components run
// It also owns the std::atomic_bool sig, which is passed over to the components
template <typename... PM>
Pipeline<PM...>::Pipeline(PM... pm) : components{pm.work_function...}, pipeline_buffers(make_buffers(components, pm...)), threads{
    // Load up each Component on a fresh thread and starting running it
    std::apply([&](auto&... component) {
        return std::array<std::thread, sizeof...(PM)> {
            std::thread([&component, this](){ component(sig); })...
        };
    }, components)} {};

template <typename... PM>
void Pipeline<PM...>::start() {};

template <typename... PM> 
void Pipeline<PM...>::stop() {};

// The aim of the make_buffers method is two-fold
// Not only is it responsible for generating the PipelineBuffers
// It also binds the inputs and outputs of Components to the correct PipelineBuffers
template <typename... PM> 
constexpr typename Pipeline<PM...>::pipeline_buffers_t Pipeline<PM...>::make_buffers(auto& components, PM... pm) {
        // names_to_indices is a static map, taking a name and mapping it to the index in the pm (pipeline_module) list
        // It is generated by first creating an index sequence as long as the number of pms
        // Then we create a static_map, by giving it a list of kv objects, unpacking the PM... and Idx... packs together
        constexpr auto names_to_indices = [&]<std::size_t... Idx>(std::index_sequence<Idx...>) {
            // changed pm.component_name
            return static_map{{kv{PM::component_name_type::value, Idx}...}};
        }(std::index_sequence_for<PM...>{});

        // pm_dependents_and_ports stores which pms use this pm as input and on which port
        // pm_dependents_and_ports[idx]: array of pairs of pm and input port idx,
        // idx is upstream to the pms in the array,
        // idx's output is used as the input of each pm in the array at the corresponding port idx
        constexpr auto pm_dependents_and_ports = [&]<std::size_t... outer_pm_index>(
            std::index_sequence<outer_pm_index...>) {
            std::array<static_vector<input_backref, sizeof...(PM)>, sizeof...(PM)> ret;

            // Fold expression over all pms passed-in as argument to make_buffers
            // std::apply to turn the input_names, within the input_name_tuple_type into a pack
            (std::apply(
                 // Iterate over all of the input_names inside a pm (call this alpha - also referred to by outer_pm_index)
                 // Alpha is dependent on the pms associated with each input_name
                 // We need to populate this information in ret
                 [&](auto... input_names) {
                    // Use lambda trick to get an index sequence for the input dependencies of alpha
                    // We return the array that is produced - pm_dependents_and_ports
                    return [&]<std::size_t... input_port_idx>(
                       std::index_sequence<input_port_idx...>, std::size_t _outer_pm_index) {
                     (
                         [&] {
                           constexpr auto input_idx =
                               names_to_indices.get(input_names.value);
                           // Add alpha as a dependency to the pm coded by index input_idx and
                           // also note the port on alpha on which is accepts data to arrive from
                           // that pm
                           ret[input_idx].push_back(input_backref{_outer_pm_index, input_port_idx});
                         }(),
                         ...);
                   }
                   (std::make_index_sequence<sizeof...(input_names)>{}, outer_pm_index);
                 },
                 typename PM::input_name_tuple_type{}),
             ...);
            return ret;
        }
        (std::index_sequence_for<PM...>{});

        // Return the completed tuple of std::monostate/PipelineBuffers,
        // depending on if that component needs an output buffer
        return [&]<std::size_t... PM_Idx>(std::index_sequence<PM_Idx...>) {
            return pipeline_buffers_t{[&] {
              if constexpr (std::is_same_v<void, typename PM::output_type>) {
                // Some components might by ComponentConsumeOnly, where they don't need a PipelineBuffer
                // So, we store a std::monostate in place of a PipelineBuffer at that place in the tuple
                return std::monostate{};
              } else {
                // We need to create and bind the PipelineBuffer for this Component
                return [&]<std::size_t... Dependent_PM_Idx, std::size_t pm_idx>(
                    std::index_sequence<Dependent_PM_Idx...>, std::integral_constant<std::size_t, pm_idx>) {
                  return PipelineBuffer<typename PM::output_type>::
                      PipelineBuffer_factory(
                          component_output_ref{std::get<pm_idx>(components)},
                          [&] {
                            constexpr std::size_t input_idx =
                                pm_dependents_and_ports[pm_idx].buf[Dependent_PM_Idx].input_idx;
                            constexpr std::size_t component_idx =
                                pm_dependents_and_ports[pm_idx].buf[Dependent_PM_Idx].pm_idx;
                            return component_input_ref_factory<input_idx>(
                                std::get<component_idx>(components));
                          }()...);
                }
                (std::make_index_sequence<pm_dependents_and_ports[PM_Idx].size>{},
                 std::integral_constant<std::size_t, PM_Idx>{});
              }
            }()...};
        }
        (std::index_sequence_for<PM...>{});
    }